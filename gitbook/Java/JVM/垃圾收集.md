# 垃圾收集

[G1垃圾收集器文档](https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html)



## 确定垃圾对象

[JVM如何判定垃圾的方法？](https://blog.csdn.net/nurture_/article/details/123130657)

可以通过下面2个方法确定对象是否需要被回收

1. 引用计数

   通过判断一个对象的引用数量决定这个对象是否需要回收. 

   优点是算法简单. 缺点是需要引入额外计数器和难以判断循环依赖

2. 可达性分析

   GCRoot对象开始寻找引用, 经过两次标记还没有可达, 就会被标记为垃圾对象

   > GC Root: 栈帧中局部变量表中的对象, 方法区中常量或者静态变量, 本地方法栈中的本地对象....等等都可以称为GC Root
   >
   > 下图`Obj7`和`Obj8`就是垃圾对象

   ![可达性分析](%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86.assets/image-20220627201634130.png)



## 垃圾回收算法

1. **标记清除算法**

   算法分为2个阶段: 

   标记阶段: 遍历所有的对象标记出存活对象和垃圾对象

   清除阶段: 遍历所有的对象删除所有的垃圾对象

   优点: 简单

   缺点: 需要遍历2次, 并且清除后会有空间碎片

2. **标记整理算法**

   算法分为2个阶段: 

   标记阶段: 遍历所有的对象标记出存活对象和垃圾对象

   整理阶段: 将标记对象向一段移动

   优点: 没有空间碎片

   缺点: 比标记清除算法要慢

3. **复制算法**

   把内存一分为二, 平时只使用一个, 触发GC时将存活对象迁移至另一个内存

   优点: 效率比标记整理快, 同时也没有内存碎片. 数据量不大时较为高效

   缺点: 浪费空间

> 效率上：复制算法>标记清除>标记整理
>
> 内存利用率：标记整理> 标记清除>复制算法
>
> 内存连续度：标记整理 = 复制算法 > 标记清除
>
> -------------------
>
> 年轻代：对象存活率不高，频繁的垃圾回收，使用“复制算法”
>
> 老年代：对象存活率相对较高，使用“标记清除”或者“标记整理算法”



## 垃圾收集器

[垃圾收集器官方文档](https://docs.oracle.com/en/java/javase/17/gctuning/available-collectors.html#GUID-F215A508-9E58-40B4-90A5-74E29BF3BD3C)

垃圾收集器就是上述算法的落地产品

* **Serial Collector**

  串行收集器. 使用单线程来执行所有垃圾收集工作. 没有线程通讯的额外开销, 但不能充分利用多核CPU. 因此在小内存(100M)下相对高效. 适用于Old和Young

* **Parallel Collector**

  并行收集器也叫作吞吐量收集器. 多线程收集. 适用于Old和Young

* **Concurrent Mark Sweep(CMS)**

  CMS收集器, 停顿时间比较短(约500ms), 使用的是标记清除法因此会有空间碎片. 适用于Old

* **Garbage-First (G1) Garbage Collector**

  G1收集器, 会尽可能的满足设定的停顿时间(约200ms), 并且很好的解决了空间碎片问题, 适用于Old和Young

* **The Z Garbage Collector**

  Z收集器, 提供一个低停顿时间(8ms). 停顿时间和堆大小无关, 但吞吐量会下降. 适用于Old和Young

* **Selecting a Collector**



按照执行类型分类

* 串行: 只有一个垃圾收集线程执行Serial Collector



## Stop the world

Stop the world(STW)是Java中一种全局暂停现象, 所有Java代码停止, native代码可以执行, 但不能与JVM交互

所有垃圾收集器都存在STW, 只是时间长短不一样

STW是为了避免业务代码在获取对象时该对象正在被移动, 导致获取错误地址