**回答问题前先停几秒, 缓解紧张, 放慢语气**



您好, 下面介绍一下我的个人信息, ~~基本情况简历都有我就不再重复了~~. 

我的个人情况是, 17年毕业, 至今已经有6年工作经验, 现在住在白云区不过面试通过之后会搬到公司附近. 闲暇之余会看下技术类的公众号, 灵光一闪时也会看下公司代码做下优化.

关于学习这一块. 平时一般通过视频快速了解一项技术, 然后通过书籍和博客查漏补缺. 同时会把学习成果输出到gitbook. 您可以看看(打开电脑, 顺便把代码也挑点给他看看)

关于职业规划, 还是比较偏向技术的, 本来想在上一家公司沉淀一下, 没想到今年就要迁回上海了, 所以我希望下家公司是一家比较稳定的公司, 可以让我安心的研究下技术

上一家公司的架构是springboot + redis + rocketMq + mysql 定时任务用的是xxl-job

主要责任是自己负责的需求模块开发还有带2个初级工程师

主要项目是一个叫车次元的小程序，这个小程序其实挺大的，有商城，游戏，社区。我主要是负责社区一块的开发



我说话不太流畅 可能是有点紧张， 希望不要介意。 我从重阳节开始才找工作， 这是第一个面试





项目亮点

项目难点

1. 项目是使用多数据源的, 比如社区项目里可能有user库, 帖子库, 活动库. 并且在框架中做了拦截, 单表操作的话首先会切换到对应的库中, 如果是多库操作, 比如一次发帖操作可能会在user/帖子/活动的库上做操作, 这时候框架就会提示`无法切换数据源`这是我们框架现有的一个问题, 原本的做法是涉及到多数据库的操作不加失误. 我的做法是将原有框架切换数据源的动作给去掉, 直接使用Atomikos(Bitronix、Narayan)做一个数据源的管理
2. 帖子创建和编辑时加密的token和后端的对不上, 





## IO

IO大概可以分为5种, BIO NIO IO多路复用 信号驱动IO AIO

BIO可以称为阻塞IO, 会在获取链接和获取数据的时候阻塞, 对应代码的Accept和Read方法

NIO也叫非阻塞IO, 非阻塞也主要体现在Accept和Read, NIO解决了Read方法的一半阻塞也即是解决了数据从网卡到内核空间的阻塞





## Spring

### Spring 生命周期

类 => 推断构造方法(用默认的) => 创建普通对象 => 依赖注入(循环依赖) => 

初始化前 => 初始化 => 初始化后 => 

AOP => 代理对象 => Bean



简单的说只有4个阶段

1. 实例化对象
2. IOC依赖注入
3. 初始化
   1. 处理Aware接口
   2. BeanPostProcessor前置处理---全局
   3. InitializingBean接口
   4. 调用对象的init-method
   5. BeanPostProcessor后置处理---全局
4. 销毁
   1. DisposableBean接口
   2. 调用对象的destroy-method



### SpringBoot 自动装配原理

[SpringBoot 自动装配原理](https://blog.csdn.net/qq_43843037/article/details/111320877)

其实就是在项目启动的时候去加载META-INF下的spring.factories文件, 将文件内的类加载到Spring容器中



### Spring事务

分为编程式事务和声明式事务

编程式事务是用**PlatformTransactionManager**或者**TransactionTemplate**硬编码控制事务. 需要手动获取事务对象控制事务的提交和回滚, 对代码侵入性较大

声明式事务是用**@Transaction**控制事务, 使用异常或transactionStatus.setRollbackOnly();来控制事务回滚. 对代码侵入性较小



### spring循环依赖

 首先循环依赖主要是a依赖b, b依赖a或者中间增加一个或多个其他组件的依赖, 再有一种情况就是a自身依赖

为了解决以上的情况spring采用缓存的方式解决

首先获取bean时会向一级缓存尝试获取, 如果获取不到则向二级缓存获取, 如果二级缓存也不存在就表示这个bean还没有实例化. 这时候就会实例化该bean并放入二级缓存中, 然后再解析@autowired. 等解析完成后会将该bean放入一级缓存中

从我上面说的可以知道如果是使用gset方式注入的bean是没有循环依赖问题的, 因为在实例化阶段二级缓存会返回对象的引用给需要用的对象. 但如果是构造器注入的方式就会提示循环依赖, 因为这个bean创建时就需要用到他所依赖的对象, 连实例化都做不到

当然构造器注入的好处就是可以限制类的组成, 而且构造器注入更会让你直观的感觉到类是否臃肿. 我个人如果公司没有要求的情况下也是使用构造器注入



### springcloud

springcloud是一个基于springboot的分布式系统框架, 提供了一系列的组件和工具用于简化分布式系统的开发和部署

核心组件有

1. eureka/nacos, 用于管理和发现微服务, 服务提供者将自身注册到eureka服务器, 服务发现者从eureka服务器中获取服务列表. 从而实现服务发现
2. loadBalancer/ribbon, 用于提供客户端的负载均衡, 可以根据服务器的负载均衡算法从服务列表中选择一个服务器进行访问从而实现负载均衡
3. feign/dubbo, 一款声明式http客户端, feign可以根据接口定义直接生成http客户端实现. 从而使代码更加简洁和易于维护
4. hystrix/sentinetl, 是一款容错组件, 用于处理分布式系统中的故障和异常, 能通过熔断, 降级, 限流的方式来保护系统的稳定性和可用性
5. zuul/getaway, 一款网关组件, 用于实现微服务的API网关, 可以用个路由, 过滤器等方式进行请求转发和处理. 从而实现微服务的统一入口和安全控制



dubbo和springcloud的区别

没什么关系, dubbo是一个轻量级的rpc框架, 针对rpc进行封装使其更加高效

springcloud则是一个微服务架构的落地技术栈, 重点在于提供良好的开箱即用的微服务组件, 用于简化分布式系统的开发和部署

如果非要做对比则应该用dubbo和feign做一个对比, 他们在微服务体系下都是一个服务间通讯组件

dubbo使用的是二进制传输数据, 占用的带宽会更少

feign则使用http协议使用json进行传输, 优势是如果使用其他异构服务扩展性会更好



熔断: 当一个微服务响应慢或者有大量超时, 此时为了保证系统整体的可用性就会禁止对该服务的调用直接返回, 防止微服务雪崩

限流: 设置一个阈值, 当调用量超过该阈值时停止后续调用

​	常用的限流算法有: 1.滑动窗口计数器 2.令牌桶 3.漏桶

降级: 当服务器压力剧增时, 暂停一些边缘业务的请求, 把资源分配给核心业务







## ES

### ES搜索为什么快

从架构上看ES的架构是一个集群里有多个节点, 一个节点里面会有多个分片, 一个分片会有多个segment. 这样架构的好处是能支持横向扩容, 只需要增加节点就能增加储存能力. 并且搜索时是基于分片的, 能将请求分发到各个节点, 充分利用CPU性能从而提高搜索效率

并且ES是基于乐观锁控制并发的, 通过version字段来保证并发的正确性, 避免加锁导致的阻塞



## Kafka

## kafka架构

kafka架构可以分为三层,

主题层, 一个主题可以配置多个分区, 每个分区又可以配置多个副本(副本数不能大于Broker数)

分区层, n个副本中只有1个是Leader分区对外提供服务, 其余是追随者副本, 只提供数据冗余

消息层, 分区中包含若干条消息, 每条消息的唯一从0开始递增

另外客户端只能和分区的leader进行交互



### kafka消息无丢失配置

Broker端需要配置禁止ISR外的副本称为Leader, Producer端需要指定ack=all并且使用带回调的send方法感知消息落盘状态. 这里的ack=all表示ISR全部落盘成功

另外可以在Consumer端关闭自动提交. 手动拉取消费完再提交位移. 但在多线程消费的场景下比较难以控制位移更新的, 也即是说可能会出现重复消费





### kafka中的 zookeeper 起到什么作用

controller选举, 检测broker是否存活, 配置管理和服务命名等作用

不过kafka也有了完全脱离zookeeper的打算. 使用基于 Raft 的共识算法, 替代 ZooKeeper,实现Controller自选举





## Redis

### AOF和RDB

AOF会以日志的形式, 记录redis的每一步修改操作到appendonly.aof中, 并且AOF文件过大的话会自动调用rewrite压缩AOF文件. AOF优点是实时性高但持久化的文件大效率较慢

RDB,redis会fork一个线程将数据写入一个二进制文件

> rewrite: redis会fork一个线程由子进程将此时redis的数据全量写入AOF中



### redis数据淘汰算法

可以指定, 具体看配置, 用的最多的是使用LRU算法, 其次是按过期顺序, 最后是随机删除

LRU算法可以将近期最少使用的键值对删除



### 缓存雪崩和缓存击穿

首先`缓存雪崩`是指储存在缓存里的数据在同一个时刻全部失效, 导致原本由缓存组件抗住的大部分请求流量全部请求到了数据库, 导致数据库压力骤增的一种现象

造成缓存雪崩的主要有3种原因

1. 缓存中间件宕机, 这种情况可以对缓存中间件做高可用集群来避免
2. 缓存中大部分的值都设置了相同的过期时间, 这种情况可以在失效时间上增加一个1-5分钟的随机值
3. 针对热点数据进行数据预热



缓存击穿是指 缓存中有一个热点数据但在某时失效了, 导致大量请求同时请求到一个key上, 导致数据库压力骤增的一种现象

1. 使用互斥锁或分布式锁来保护缓存，防止多个线程同时去查询数据库
2. 在缓存失效时，通过异步更新缓存，而不是同步更新，以避免大量的请求同时访问数据库。



缓存穿透指的是短时间有大量缓存不存在的key请求到了应用里. 这些key会直接击穿缓存组件将请求穿透到数据库从而造成数据库压力

造成缓存击穿一般有2种原因

1. 对于查询不到的数据, 将空结果缓存起来, 可以设置较短时间, 防止频繁查询
2. 使用布隆过滤器快速判断请求的key是否存在



## JVM

### 运行时数据区

运行时数据区包括: 方法区, 堆. Java虚拟机栈, PC计数器, 本地方法栈

方法区和堆会随着JVM创建而创建. 销毁而销毁, 后面三个则是跟随着线程的生命周期



### 类加载机制

类加载分为3个阶段, 装载 链接 初始化

装载就是将Class文件读取到内存中. 

链接就是将类或者接口并入虚拟机运行时状态, 具体可以分为验证 准备 解析 访问控制和复写. 验证就是验证文件是否合法, 准备就是给变量赋予初始值. 解析就是将符号应用转为直接应用并且将常量池转换为运行时常量池

初始化就是为属性赋予正在的初始值



### 垃圾回收算法

标记清除算法, 分为2个阶段, 一个标记阶段是遍历所有对象并将标记出存活对象和垃圾对象, 一个是清除阶段会遍历并删除所有垃圾对象. 算法的优点是简单速度快, 缺点是会有空间碎片, CMS就是使用这个算法, 因此需要大的内存来规避空间碎片导致的OOM

标记整理算法, 也分为2个阶段, 第二个阶段为整理阶段, 会移动存活对象到一侧. 优点是没有空间碎片, 缺点是比标记清除慢

复制算法, 将内存分为2块区域, 平时只使用一块, GC时将存活对象直接移动到另一块区域, 优点是在小空间的情况下速度快, 缺点是浪费内存. 通常使用在Young区.



### 确定垃圾对象_可达性分析

2个算法, 一个是引用计数, 不过引用计数不能识别循环依赖. 一种是可达性分析, 会从GC root对象开始寻找, 经过2次标记还没达到可达就会标记为垃圾对象

GCroot对象一般从Java虚拟机栈和本地方法栈的栈帧中的本地变量表中寻找, 还有就是方法区中的运行时常量池中寻找





## Mybatis

一级缓存和二级缓存

mybatis设置了两级缓存来减少对数据库的查询次数

一级缓存时sqlsession级别的, 后续sql如果在命中换成的前提下就可以省略一次查询. 但想要在全局基本只靠一级缓存是无法做到的. 因此mybatis引入了二级缓存.

二级缓存当多个用户查询时, 如果其中一个命中那么后续都会从缓存中获取

其中一级缓存原理是: sqlsession对象会内置一个Executor, 而Executor里会有一个localCache对象. 当执行一次查询时mybatis会在localCache中进行查询, 如果命中则直接返回, 否则查数据库并将结果缓存起来, 所以一级缓存的声明周期也是sqlsession级别的. 需要注意的是在分布式系统中可能会因为一级缓存导致脏读

其中二级缓存的原理是: 在Executor的基础上做一个CachingExecutor的装饰器, 在查询一级缓存之前首先会通过CachingExecutor进行查询. CachingExecutor内部会缓存namespace级别的缓存. 所以二级缓存是全局的并且相对一级缓存来说可以被多个sqlsession共享. 









## Nacos

### 命名空间(Namespace)和gruopid有什么区别

命名空间用于隔离配置信息，使得不同环境中的微服务能够使用不同的配置集。

Group ID 用于将同一服务的不同版本或变种进行区分





### 心跳

默认的心跳周期是5s，心跳的超时时间是15s，就意味着如果超过15秒不发送心跳，Nacos就认为这个服务不健康了，超过30秒该实例就将被Nacos删除下线。







## Spring



### Spring中的反射

1. **依赖注入**：
   - Spring通过反射来实现依赖注入。当容器初始化时，它会通过反射检查类的构造方法、字段、方法等，然后实例化对象并将依赖注入到相应的地方。
2. **Bean的实例化**：
   - Spring容器通过反射来实例化Bean。在配置文件或者注解中指定Bean的类名，Spring会使用反射创建该类的实例。
3. **AOP的实现**：
   - Spring AOP通过代理模式和反射来实现切面（Aspect）的横切逻辑。当一个类被代理时，Spring会通过反射动态生成代理类，将切面逻辑织入到目标类的方法中。
4. **处理注解**：
   - Spring框架大量使用了注解，例如`@Autowired`、`@Component`等。在运行时，Spring通过反射来处理这些注解，实现相应的功能。
5. **处理配置信息**：
   - Spring中的配置信息通常以XML或注解的形式存在。在容器启动时，Spring会通过反射读取这些配置信息，并进行相应的初始化。
6. **动态代理**：
   - Spring利用反射实现动态代理。在运行时，Spring会使用Java动态代理或者CGLIB来生成代理类，实现横切逻辑的织入。



### AOP原理

通过**动态代理**实现的。如果我们为`Spring`的某个`bean`配置了切面，那么`Spring`在创建这个`bean`的时候，实际上创建的是这个`bean`的一个代理对象，我们后续对`bean`中方法的调用，实际上调用的是代理类重写的代理方法。而`Spring`的`AOP`使用了两种动态代理，分别是**JDK的动态代理**，以及**CGLib的动态代理**。









