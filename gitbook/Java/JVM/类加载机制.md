# 类加载机制

[类加载官方文档](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html)

 类加载分为三个阶段

1. 装载(Loading)
2. 链接(Linking)
3. 初始化(Initializing)



## 装载loading

找到class文件所在的全路径, 然后装载到内存中

java又是一门面向对象的语言, 所以针对不同的类有不同的类装载器, 可以分为4类加载器

1. Booststrap

   加载rt包下的类

2. Extension

   加载拓展包下的类

3. Application

   加载classpath中指定的类

4. Custom

   自定义的类加载器

![类加载器](%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.assets/image-20220627143218455.png)



类加载器使用顺序由上往下, 优先使用顶层加载器

```java
// 可以在java.lang.ClassLoader.loadClass(String name, boolean resolve)看相应的过程
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    // 主要看这个, 如果有父类加载器优先使用父类加载器
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }
		//....
    }
}
```



### 双亲委派机制

上面代码就是面试常问的**双亲委派机制**, 使用双亲委派可以避免开发者篡改JVM底层的类. 

比如`java.lang.String`. 如果本地也定义了一个`java.lang.String`, 在双亲委派的机制下会优先使用Booststrap加载器加载, 此时加载的是rt包下的String. 而不是自定义的String

当然从`java.lang.ClassLoader`中可以看出双亲委派不是必须的. 我们可以自定义一个加载器, 将`parent.loadClass(name, false);`这段代码的执行时机改为`this.loadClass(name, false) == null`才进行父类加载. 

打破双亲委派机制的方法还有: SPI机制, OSGI机制

